// server.js
import 'dotenv/config';
import express from 'express';
import helmet from 'helmet';
import cors from 'cors';
import compression from 'compression';
import cookieParser from 'cookie-parser';
import path from 'node:path';
import fs from 'node:fs';
import { fileURLToPath } from 'node:url';
import YAML from 'yaml';
import pino from 'pino';
import mongoose from 'mongoose';
import client from 'prom-client';

// Routes
import authRoutes from './routes/authRoutes.js'; // must define /csrf, /signup, /login, /me, etc.

// Optional Swagger UI (loaded only if OpenAPI is present)
import swaggerUi from 'swagger-ui-express';

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Basics
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const __filename = fileURLToPath(import.meta.url);
const __dirname  = path.dirname(__filename);

const isProd = process.env.NODE_ENV === 'production';
const PORT   = Number(process.env.PORT || 5000);

// Keep logging simple and compatible (avoid pino-http mismatch)
const log = pino({ level: process.env.LOG_LEVEL || (isProd ? 'info' : 'debug') });

// Handle fatals early
process.on('uncaughtException', (err) => {
  try { log.error({ err }, 'UNCAUGHT_EXCEPTION'); } finally { process.exit(1); }
});
process.on('unhandledRejection', (err) => {
  log.error({ err }, 'UNHANDLED_REJECTION');
});

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Express app
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const app = express();
// mount auth routes on both bases
app.use('/auth', authRoutes);
app.use('/api/auth', authRoutes);
app.set('trust proxy', 1);

// Security + parsing
app.use(
  helmet({
    crossOriginOpenerPolicy: { policy: 'same-origin' },
    crossOriginResourcePolicy: { policy: 'cross-origin' }, // allow Swagger assets if hosted elsewhere
  })
);
app.use(compression());
app.use(cookieParser());
app.use(express.json());
app.use(express.json({ limit: '1mb' }));
app.use(express.urlencoded({ extended: false }));

// Minimal, robust request logging without pino-http (avoids stringifySym issues)
app.use((req, res, next) => {
  const start = process.hrtime.bigint();
  const { method, url } = req;
  res.on('finish', () => {
    const ms = Number((process.hrtime.bigint() - start) / 1000000n);
    log.info({ method, url, statusCode: res.statusCode, responseTime: ms }, 'request completed');
  });
  next();
});

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// CORS
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const raw = (process.env.ALLOWED_ORIGINS || '').trim();
let allowList = raw ? raw.split(',').map(s => s.trim()).filter(Boolean) : [];
// If unset, default to "all" for local dev ergonomics. In prod, prefer explicit ALLOWED_ORIGINS.
if (!allowList.length && !isProd) allowList = ['*'];

const corsOptions = {
  origin(origin, cb) {
    if (!origin) return cb(null, true);           // non-CORS or same-origin XHR
    if (allowList.includes('*')) return cb(null, true);
    try {
      // allow exact string match or base-origin match
      const ok = allowList.some(allowed => {
        if (!allowed) return false;
        if (allowed === origin) return true;
        try { return new URL(allowed).origin === new URL(origin).origin; } catch { return false; }
      });
      return cb(ok ? null : new Error(`CORS blocked for: ${origin}`), ok);
    } catch {
      return cb(new Error(`CORS parse error for: ${origin}`), false);
    }
  },
  credentials: true,
};
app.use(cors(corsOptions));
log.info(`CORS: allowed origins -> ${allowList.length ? allowList.join(', ') : '(all)'}`);

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// OpenAPI: /openapi.json and /docs (if docs/openapi.yaml exists)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function loadOpenApi() {
  const openapiPath = path.join(__dirname, 'docs', 'openapi.yaml');
  try {
    const yml = fs.readFileSync(openapiPath, 'utf8');
    return YAML.parse(yml);
  } catch {
    return {
      openapi: '3.0.3',
      info: { title: 'MicroCourse API', version: '1.0.0', license: { name: 'MIT', url: 'https://opensource.org/licenses/MIT' } },
      servers: [{ url: '/api', description: 'Base API' }],
      paths: {},
    };
  }
}
const openapiDoc = loadOpenApi();

app.get('/openapi.json', (_req, res) => res.json(openapiDoc));
app.use('/docs', swaggerUi.serve, swaggerUi.setup(openapiDoc, { explorer: false }));

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Prometheus metrics
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
client.collectDefaultMetrics();
app.get('/metrics', async (_req, res) => {
  res.set('Content-Type', client.register.contentType);
  res.end(await client.register.metrics());
});

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Healthz
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
app.get('/healthz', (_req, res) => res.json({ ok: true }));

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
/**
 * Mongo (Atlas or local)
 * Uses ONE resolved variable and never falls back to localhost implicitly.
 */
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function connectMongo() {
  const MONGO =
    process.env.MONGO_URL ||     // preferred
    process.env.MONGODB_URI ||
    process.env.MONGO_URI;

  if (!MONGO) {
    log.error('Missing Mongo URI. Set MONGO_URL (or MONGODB_URI / MONGO_URI).');
    process.exit(1);
  }

  // Log which host we target (non-sensitive)
  try {
    const targetHost = new URL(MONGO.replace(/^mongodb\+srv:\/\//, 'https://')).host;
    // helpful line you've been using:
    console.log('Mongo target host:', targetHost);
  } catch {}

  await mongoose
    .connect(MONGO, {
      serverSelectionTimeoutMS: 10_000,
      autoIndex: !isProd,
    })
    .catch((err) => {
      log.error({ err }, 'FAILED_TO_START');
      process.exit(1);
    });

  log.info('âœ… Mongo connected');
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// API Routes
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const api = express.Router();

// Mount auth under /api/auth  (your authRoutes should define /csrf, /signup, /login, /me, etc.)
api.use('/auth', authRoutes);

app.use('/api', api);

// 404
app.use((req, res, next) => {
  if (res.headersSent) return next();
  res.status(404).json({ success: false, message: 'Not found' });
});

// Generic error handler
app.use((err, _req, res, _next) => {
  const status = err.status || err.statusCode || 500;
  const message = isProd && status === 500 ? 'Internal Server Error' : err.message || String(err);
  if (status >= 500) log.error({ err }, 'Unhandled error');
  res.status(status).json({ success: false, message });
});

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Start
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function start() {
  await connectMongo();

  const server = app.listen(PORT, () => {
    log.info(`âœ… Server listening on :${PORT} (${isProd ? 'production' : 'development'})`);
  });

  server.on('error', (e) => {
    if (e.code === 'EADDRINUSE') {
      log.error(`Port ${PORT} in use. Set PORT to a free port or stop the other process.`);
    } else {
      log.error({ err: e }, 'Server error');
    }
    process.exit(1);
  });
}

start().catch((err) => {
  log.error({ err }, 'FAILED_TO_START');
  process.exit(1);
});


