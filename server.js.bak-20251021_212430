/* eslint-disable no-console */
require("dotenv").config();

onst mongoose = require("mongoose");

(async () => {
  if (process.env.MONGO_URL) {
    await mongoose.connect(process.env.MONGO_URL, { dbName: process.env.MONGO_DB || "microcourse" });
    console.log("[ok] Mongo connected");
  } else {
    console.warn("[warn] MONGO_URL not set; using in-memory store");
  }
})();

const express = require("express");
const cors = require("cors");
const helmet = require("helmet");
const compression = require("compression");
const morgan = require("morgan");
const path = require("path");

/** helpers **/
function parseCSV(input) {
  if (!input) return [];
  return String(input)
    .split(",")
    .map(s => s.trim())
    .filter(Boolean);
}

const PORT = Number(process.env.PORT || 10003);
const IS_PROD = (process.env.NODE_ENV || "development") === "production";
const TRUST_PROXY = String(process.env.TRUST_PROXY || "").toLowerCase() === "true";

// --- Allowed UI origins (env or sensible defaults) ---
const DEFAULT_ORIGINS = ["http://localhost:5173","http://localhost:5174","http://localhost:5175"];
const ALLOWED_ORIGINS = [
  ...new Set([
    ...DEFAULT_ORIGINS,
    ...parseCSV(process.env.ADMIN_ORIGINS),
  ])
];

// --- CORS config: exact match only (safe) ---
const corsOptions = {
  origin(origin, cb) {
    // allow server-to-server (no Origin header) and CLI tools
    if (!origin) return cb(null, true);
    if (ALLOWED_ORIGINS.includes(origin)) return cb(null, true);
    const err = new Error("Request origin is not allowed by CORS");
    err.statusCode = 403;
    cb(err);
  },
  credentials: true,
  methods: ["GET","POST","PUT","PATCH","DELETE","OPTIONS"],
  allowedHeaders: ["Content-Type","Authorization","X-Requested-With"]
};

// --- app ---
const app = express();
if (TRUST_PROXY) app.set("trust proxy", true);

// security headers (dev-friendly COOP/COEP off to avoid cross-origin crash in dev)
app.use(helmet({
  crossOriginOpenerPolicy: false,
  crossOriginEmbedderPolicy: false
}));

// parsers
const KB = 1024, MB = 1024 * KB;
const MAX_JSON = Number(process.env.MAX_BODY_JSON ?? 1*MB);
const MAX_URL  = Number(process.env.MAX_BODY_URL  ?? 1*MB);
app.use(express.json({ limit: MAX_JSON }));
app.use(express.urlencoded({ extended: true, limit: MAX_URL }));
app.use(compression());


const rateLimit = require("express-rate-limit");
app.use(rateLimit({ windowMs: 60_000, max: 120, standardHeaders: true, legacyHeaders: false }));

// logging
if (!IS_PROD) app.use(morgan("dev"));

// CORS + preflight
app.use(cors(corsOptions));
app.options("*", cors(corsOptions));

// --- health ---
app.get("/health", (_req, res) => {
  res.json({
    ok: true,
    env: IS_PROD ? "production" : "development",
    storage: process.env.MONGO_URL ? "mongo" : "memory",
    uptime_seconds: process.uptime() | 0,
    timestamp: new Date().toISOString(),
    videoServiceBase: process.env.VIDEO_SERVICE_BASE || "http://localhost:" + PORT
  });
});

// --- auth mounting ---
// We accept either a Router export, or a function returning a Router.
function mountAuth(base) {
  try {
    // prefer local ./auth.js
    const mod = require("./auth.js");
    const buildIsFn = (k) => typeof mod[k] === "function";
    let router = null;

    if (typeof mod === "function") {
      router = mod();
    } else if (mod && typeof mod === "object") {
      if (buildIsFn("router")) router = mod.router();
      else if (mod.router && typeof mod.router === "object" && typeof mod.router.use === "function") {
        router = mod.router;
      } else if (buildIsFn("buildRouter")) {
        router = mod.buildRouter();
      }
    }

    if (!router || typeof router.use !== "function") {
      throw new Error("auth module did not return a Router");
    }
    app.use(base, router);
    console.log(`[ok] Mounted auth at ${base}`);
  } catch (e) {
    console.warn("[warn] auth mount failed or not found:", e.message);
  }
}

mountAuth("/api/auth");

// --- optional static/uploads (no-op until you add dirs) ---
// const PUBLIC_DIR = path.join(__dirname, "public");
// if (false && require("fs").existsSync(PUBLIC_DIR)) {
//   app.use("/public", express.static(PUBLIC_DIR));
// }

// --- not found ---
app.all("*", (req, res) => {
  res.status(404).json({ success: false, message: "No route for " + req.method + " " + req.originalUrl });
});

// --- error handler (also handles CORS denials) ---
app.use((err, _req, res, _next) => {
  const status = Number(err.statusCode || err.status || 500);
  const msg = status === 403 && /CORS/i.test(String(err.message)) ? "Request origin is not allowed by CORS" : (err.message || "Internal Server Error");
  if (!IS_PROD) console.error("[error]", status, msg);
  res.status(status).json({ success: false, message: msg });
});

// --- start & graceful shutdown ---
let server = null;

async function start() {
  return new Promise((resolve, reject) => {
    server = app.listen(PORT, () => {
      console.log(`[ok] Server running on port ${PORT}`);
      console.log(`[ok] Allowed UI origins: ${ALLOWED_ORIGINS.join(", ") || "(none)"}`);
      resolve();
    });
    server.on("error", reject);
  });
}

async function shutdown(reason) {
  try {
    console.log("[info] shutting down...", reason ? `(${reason})` : "");
    if (server) {
      await new Promise(r => server.close(() => r(null)));
      console.log("[ok] HTTP server closed");
    }
  } catch (e) {
    console.error("[fatal] shutdown error:", e);
  } finally {
    process.exit(0);
  }
}

process.on("SIGINT",  () => shutdown("SIGINT"));
process.on("SIGTERM", () => shutdown("SIGTERM"));
process.on("unhandledRejection", (r) => { console.error("[fatal] Unhandled Rejection:", r); });
process.on("uncaughtException", (e) => { console.error("[fatal] Uncaught Exception:", e); });

if (require.main === module) {
  start().catch(e => {
    console.error("[fatal] failed to start:", e);
    process.exit(1);
  });
}

module.exports = app;
