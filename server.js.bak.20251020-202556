/* eslint-disable no-console */
/* Core + safety middleware */
require("dotenv").config();
const express     = require("express");
const cors        = require("cors");
const helmet      = require("helmet");
const compression = require("compression");
const morgan      = require("morgan");
const path        = require("path");
const fs          = require("fs");

/* Optional DB (only if MONGO_URI is set) */
let mongoose = null;
if (process.env.MONGO_URI) {
  try { mongoose = require("mongoose"); } catch { mongoose = null; }
}

/* --------------------------- config helpers --------------------------- */
const isProd = process.env.NODE_ENV === "production";
const PORT   = Number(process.env.PORT || 10003);

const MAX_JSON_SIZE  = process.env.MAX_JSON_SIZE  || "1mb";
const MAX_BODY_SIZE  = process.env.MAX_BODY_SIZE  || "1mb";
const PUBLIC_DIR     = process.env.PUBLIC_DIR     || path.join(__dirname, "public");
const UPLOAD_DIR     = process.env.UPLOAD_DIR     || path.join(__dirname, "uploads");
const TRUST_PROXY    = String(process.env.TRUST_PROXY || "false").toLowerCase() === "true";

/** turn comma/space/newline separated env var into clean array */
function parseList(src) {
  if (!src) return [];
  return String(src)
    .split(/[\s,]+/g)
    .map(s => s.trim())
    .filter(Boolean);
}

/* allowlist for CORS (UI origins) */
const ADMIN_ORIGINS  = parseList(process.env.ADMIN_ORIGINS);
const ALLOWED_ORIGINS= new Set([
  "http://localhost:5173",
  "http://localhost:5174",
  "http://localhost:5175",
  ...ADMIN_ORIGINS,
]);

/* ------------------------------ app init ------------------------------ */
const app = express();
if (TRUST_PROXY) app.set("trust proxy", true);

/* security headers (safe defaults; avoid invalid COOP policy) */
app.use(helmet({
  crossOriginOpenerPolicy: { policy: "same-origin-allow-popups" }, // avoid 'cross-origin' error
  crossOriginEmbedderPolicy: false,                                 // often incompatible with dev stacks
}));

/* parsers + gzip + logs */
app.use(express.json({ limit: MAX_JSON_SIZE }));
app.use(express.urlencoded({ extended: true, limit: MAX_BODY_SIZE }));
app.use(compression());
if (!isProd) app.use(morgan("dev"));

/* robust CORS setup (exact match, with preflight) */
const corsOptions = {
  origin(origin, cb) {
    if (!origin) return cb(null, true);                // tools like curl/Postman
    if (ALLOWED_ORIGINS.has(origin)) return cb(null, true);
    const err = new Error("CORS: origin not allowed");
    err.code = "CORS_NOT_ALLOWED";
    return cb(err, false);
  },
  credentials: true,
  methods: ["GET","POST","PUT","PATCH","DELETE","OPTIONS"],
  allowedHeaders: ["Content-Type","Authorization"]
};
app.use(cors(corsOptions));
app.options("*", cors(corsOptions)); // preflight

/* serve static uploads if present (handy for images/files) */
if (fs.existsSync(UPLOAD_DIR)) {
  app.use("/uploads", express.static(UPLOAD_DIR, { maxAge: "3d", etag: true }));
}

/* --------------------------- feature mounting ------------------------- */
/* tiny async wrapper so thrown errors go to Express error handler */
const wrap = fn => (req,res,next) => Promise.resolve(fn(req,res,next)).catch(next);

/* Try to load auth handlers and build a Router at /auth */
function buildAuthRouter(mod) {
  const r = express.Router();
  if (!mod || typeof mod !== "object") return null;

  if (typeof mod.registerUser === "function") r.post("/register", wrap(mod.registerUser));
  if (typeof mod.loginUser    === "function") r.post("/login",    wrap(mod.loginUser));
  if (typeof mod.logoutUser   === "function") r.post("/logout",   wrap(mod.logoutUser));

  // include any optional helpers that expect (req,res)
  if (r.stack.length === 0) return null;
  return r;
}

try {
  const auth = require("./auth.js"); // expected export: { registerUser, loginUser, ... }
  const authRouter = buildAuthRouter(auth);
  if (authRouter) {
    app.use("/auth", authRouter);
    console.log("[ok] Mounted auth routes at /auth");
  } else {
    console.warn("[warn] auth module loaded but no handlers recognized");
  }
} catch (e) {
  console.warn("[warn] auth module not found:", e.message);
}

/* Optional: uploads router if you have one */
try {
  const uploads = require("./uploads.js");
  const isRouter = (x) => x && typeof x.use === "function" && typeof x.handle === "function";
  const router = isRouter(uploads?.router) ? uploads.router : (isRouter(uploads) ? uploads : null);
  if (router) {
    app.use("/upload", router);
    console.log("[ok] Mounted uploads route at /upload");
  }
} catch { /* ignore */ }

/* Optional: OpenAPI JSON if you export it */
try {
  const spec = require("./openapi.js");
  const openapi = spec?.openapi || spec?.default || spec;
  if (openapi && typeof openapi === "object") {
    app.get("/openapi.json", (_req, res) => res.json(openapi));
    console.log("[ok] OpenAPI served at /openapi.json");
  }
} catch { /* ignore */ }

/* Health */
app.get("/health", (_req, res) => {
  res.json({
    ok: true,
    env: isProd ? "production" : "development",
    storage: process.env.MONGO_URI ? "mongo" : "none",
    uptime_seconds: Math.floor(process.uptime()),
    timestamp: new Date().toISOString(),
    videoServiceBase: process.env.VIDEO_SERVICE_BASE || `http://localhost:${PORT}`,
  });
});

/* -------- DEV-ONLY seed route (remove after first successful login) --- */
if (!isProd) {
  try {
    const auth = require("./auth.js");
    if (auth?.registerUser) {
      app.post("/dev/seed-admin", (req, res, next) => {
        req.body = {
          email:    process.env.SEED_ADMIN_EMAIL    || "owner@example.com",
          password: process.env.SEED_ADMIN_PASSWORD || "passw0rd",
        };
        return auth.registerUser(req, res, next);
      });
      console.log("[dev] /dev/seed-admin enabled (remove when done).");
    }
  } catch { /* ignore */ }
}

/* ------------------------------- errors ------------------------------- */
/* 404 */
app.all("*", (req, res) => {
  res.status(404).json({ success: false, message: `No route for ${req.method} ${req.originalUrl}` });
});

/* CORS error prettifier */
app.use((err, _req, res, next) => {
  if (err?.code === "CORS_NOT_ALLOWED") {
    return res.status(403).json({ success: false, message: "Request origin is not allowed by CORS" });
  }
  return next(err);
});

/* default errors */
app.use((err, req, res, _next) => {
  const status = Number(err.status || err.statusCode || 500);
  const payload = {
    success: false,
    message: status >= 500 ? "Internal Server Error" : (err.message || "Request failed"),
  };
  if (!isProd) payload.stack = err.stack;
  console.error("[error]", status, req.method, req.originalUrl, "-", err.message);
  res.status(status).json(payload);
});

/* ------------------------------ startup ------------------------------- */
let server = null;

async function connectMongo() {
  if (!mongoose || !process.env.MONGO_URI) return;
  if (mongoose.connection?.readyState === 1) return;
  mongoose.set("strictQuery", true);
  await mongoose.connect(process.env.MONGO_URI, { dbName: process.env.MONGO_DB || "microcourse" });
  console.log("[ok] Mongo connected:", mongoose.connection.name);
}

async function startServer() {
  await connectMongo();
  await new Promise((resolve, reject) => {
    server = app.listen(PORT, () => {
      console.log(`[ok] Server running on port ${PORT}`);
      console.log(`[ok] Allowed UI origins: ${[...ALLOWED_ORIGINS].join(", ") || "(none)"}`);
      resolve();
    }).on("error", reject);
  });
}

/* graceful shutdown */
async function shutdown() {
  console.log("[info] Shutting down...");
  try {
    if (server) await new Promise(r => server.close(r));
    if (mongoose && mongoose.connection?.readyState === 1) {
      await mongoose.disconnect();
    }
    process.exit(0);
  } catch (e) {
    console.error("[fatal] shutdown error:", e);
    process.exit(1);
  }
}
process.on("SIGINT",  shutdown);
process.on("SIGTERM", shutdown);
process.on("unhandledRejection", (r) => console.error("[fatal] Unhandled Rejection:", r));
process.on("uncaughtException", (e) => console.error("[fatal] Uncaught Exception:", e));

/* expose for tests + start if main */
module.exports = app;
if (require.main === module) {
  startServer().catch(e => {
    console.error("[fatal] Startup error:", e);
    process.exit(1);
  });
}
