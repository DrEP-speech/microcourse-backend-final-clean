const jwt = require("jsonwebtoken");
const bcrypt = require("bcryptjs");

// If you have a User model, keep this require. If not, your existing code likely does.
// Adjust path if your repo stores models elsewhere.
let User;
try { User = require("../models/User"); } catch (_) { User = null; }

function signToken(user) {
  const payload = {
    id: user._id?.toString?.() ?? user.id,
    email: user.email,
    role: user.role || "student"
  };
  return jwt.sign(payload, process.env.JWT_SECRET, { expiresIn: process.env.JWT_EXPIRES_IN || "7d" });
}

function setAuthCookie(res, token) {
  // cookie-safe defaults for local dev
  res.cookie("token", token, {
    httpOnly: true,
    sameSite: "lax",
    secure: false,
    path: "/"
  });
}

exports.register = async (req, res) => {
  try {
    const { email, password, role } = req.body || {};
    if (!email || !password) return res.status(400).json({ ok: false, error: "MISSING_FIELDS" });
    if (!User) return res.status(500).json({ ok: false, error: "USER_MODEL_MISSING" });

    const existing = await User.findOne({ email });
    if (existing) return res.status(409).json({ ok: false, error: "EMAIL_EXISTS" });

    const hashed = await bcrypt.hash(password, 10);
    const user = await User.create({ email, password: hashed, role: role || "student" });

    const token = signToken(user);
    setAuthCookie(res, token);

    return res.json({
      ok: true,
      user: { id: user._id, email: user.email, role: user.role || "student" },
      token
    });
  } catch (e) {
    return res.status(500).json({ ok: false, error: "REGISTER_FAILED" });
  }
};

exports.login = async (req, res) => {
  try {
    const { email, password } = req.body || {};
    if (!email || !password) return res.status(400).json({ ok: false, error: "MISSING_FIELDS" });
    if (!User) return res.status(500).json({ ok: false, error: "USER_MODEL_MISSING" });

    const user = await User.findOne({ email });
    if (!user) return res.status(401).json({ ok: false, error: "BAD_CREDENTIALS" });

    const ok = await bcrypt.compare(password, user.password);
    if (!ok) return res.status(401).json({ ok: false, error: "BAD_CREDENTIALS" });

    const token = signToken(user);
    setAuthCookie(res, token);

    return res.json({
      ok: true,
      user: { id: user._id, email: user.email, role: user.role || "student" },
      token
    });
  } catch (e) {
    return res.status(500).json({ ok: false, error: "LOGIN_FAILED" });
  }
};

exports.me = async (req, res) => {
  return res.json({ ok: true, user: req.user || null });
};